use super::{Draft, IClashConfig, IProfiles, IRuntime, IVerge};
use crate::{
    any_err,
    core::{service, sysopt},
    enhance,
    error::{AppError, AppResult},
    utils::{dirs, help},
};
use once_cell::sync::OnceCell;
use rust_i18n::t;
use serde_yaml::Mapping;
use std::{env::temp_dir, path::PathBuf, sync::Arc};

pub const RUNTIME_CONFIG: &str = "clash-verge.yaml";
pub const CHECK_CONFIG: &str = "clash-verge-check.yaml";

pub struct Config {
    clash_config: Arc<Draft<IClashConfig>>,
    verge_config: Arc<Draft<IVerge>>,
    profiles_config: Arc<Draft<IProfiles>>,
    runtime_config: Arc<Draft<IRuntime>>,
}

impl Config {
    pub fn global() -> &'static Config {
        static CONFIG: OnceCell<Config> = OnceCell::new();

        CONFIG.get_or_init(|| Config {
            clash_config: Arc::new(Draft::from(IClashConfig::new())),
            verge_config: Arc::new(Draft::from(IVerge::new())),
            profiles_config: Arc::new(Draft::from(IProfiles::new())),
            runtime_config: Arc::new(Draft::from(IRuntime::new())),
        })
    }

    pub fn clash() -> Arc<Draft<IClashConfig>> {
        Self::global().clash_config.clone()
    }

    pub fn verge() -> Arc<Draft<IVerge>> {
        Self::global().verge_config.clone()
    }

    pub fn profiles() -> Arc<Draft<IProfiles>> {
        Self::global().profiles_config.clone()
    }

    pub fn runtime() -> Arc<Draft<IRuntime>> {
        Self::global().runtime_config.clone()
    }

    /// 初始化订阅
    pub fn init_config() -> AppResult<()> {
        crate::log_err!(Self::generate());
        if let Err(err) = Self::generate_file(ConfigType::Run) {
            tracing::error!("{err}");
            let runtime_path = dirs::app_home_dir()?.join(RUNTIME_CONFIG);
            // 如果不存在就将默认的clash文件拿过来
            if !runtime_path.exists() {
                help::save_yaml(
                    &runtime_path,
                    &Config::clash().latest().0,
                    Some("# Clash Verge Runtime"),
                )?;
            }
        }
        Ok(())
    }

    /// 将订阅丢到对应的文件中
    pub fn generate_file(config_type: ConfigType) -> AppResult<PathBuf> {
        let path = match config_type {
            ConfigType::Run => dirs::app_home_dir()?.join(RUNTIME_CONFIG),
            ConfigType::RuntimeCheck => temp_dir().join(CHECK_CONFIG),
            ConfigType::MappingCheck(_) => temp_dir().join(CHECK_CONFIG),
        };

        let runtime_config = Config::runtime();
        let runtime_config = runtime_config.latest();
        let config = match config_type {
            ConfigType::Run | ConfigType::RuntimeCheck => runtime_config
                .config
                .as_ref()
                .ok_or(any_err!("{}", t!("runtime.config.get.failed")))?,
            ConfigType::MappingCheck(ref check_config) => check_config,
        };

        help::save_yaml(&path, config, Some("# Generated by Clash Verge"))?;
        Ok(path)
    }

    /// 生成订阅存好
    pub fn generate() -> AppResult<()> {
        let (config, logs) = enhance::enhance();

        *Config::runtime().draft() = IRuntime {
            config: Some(config),
            chain_logs: logs,
        };

        Ok(())
    }

    /// reload config from file
    ///
    /// if config need restart app, return true
    pub async fn reload() -> AppResult<()> {
        let clash_config = Self::clash();
        let verge_config = Self::verge();
        let profiles_config = Self::profiles();
        let runtime_config = Self::runtime();

        // need to resolve auto launch file
        let old_enable_auto_launch = verge_config.latest().enable_auto_launch.unwrap_or(false);

        // reload config data from yaml file
        clash_config.clear_and_replace(IClashConfig::new());
        verge_config.clear_and_replace(IVerge::new());
        profiles_config.clear_and_replace(IProfiles::new());
        runtime_config.clear_and_replace(IRuntime::new());

        // generate runtime config
        Self::init_config()?;

        // resolve auto launch
        let enable_auto_launch = verge_config.latest().enable_auto_launch.unwrap_or(false);
        if old_enable_auto_launch != enable_auto_launch {
            verge_config.data_mut().patch_config(IVerge {
                enable_auto_launch: Some(enable_auto_launch),
                ..IVerge::default()
            });
            verge_config.data().save_file()?;
            sysopt::Sysopt::global().update_launch()?;
        }

        // resolve service mode
        let enable_service_mode = verge_config.latest().enable_service_mode.unwrap_or(false);
        if enable_service_mode && service::check_service().await.is_err() {
            verge_config.data_mut().patch_config(IVerge {
                enable_service_mode: Some(false),
                ..IVerge::default()
            });
            verge_config.data().save_file()?;
        }

        Ok(())
    }
}

#[derive(Debug)]
pub enum ConfigType {
    Run,
    RuntimeCheck,
    MappingCheck(Mapping),
}
